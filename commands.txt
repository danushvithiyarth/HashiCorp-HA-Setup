
### Note here all the vault command is been executed from the vault-0 Master pod.

1. Create Storage Class:

kubectl apply -f sc.yaml 


2. Create helm repo with vault_values.yaml

kubectl create ns vault 

helm install vault hashicorp/vault -n vault -f vault_values.yaml


3. Expose vault UI by editing the vault service to LB:

kubectl edit svc vault -n vault

## Open Port 8200


4. To unseal the vault pods which are been sealed:

a. Generate init tokens:

kubectl exec -n vault -it vault-0 -- vault operator init

save the tokens the 5 unseal tokens with the Cluster tokens

Ex:
Unseal Key 1: /KXsnVj9EVbOB
Unseal Key 2: kVPMNsL7Us2YY
Unseal Key 3: LyHTf+DERjb5YL
Unseal Key 4: PDMusT+iLgWRcG
Unseal Key 5: tbO2m6tfCRt9K6

Initial Root Token: hvs.JtzVm4

b. Unseal the pods using three or more Unseal token:

kubectl exec -n vault -it vault-0 -- vault operator unseal kVPMNsL7Us2YYdUS

Run this command with other tokens for every pods like:

kubectl exec -n vault -it vault-1 -- vault operator unseal kVPMNsL7Us2YYdUS

kubectl exec -n vault -it vault-2 -- vault operator unseal kVPMNsL7Us2YYdUS


5. Login into vault:

kubectl exec -n vault -it vault-0 -- vault login <Initial root token>

After this we can login into vault UI using the LB service url in 8200 port.


6. To allow Kubernetes and vault communication:

kubectl exec -n vault -it vault-0 -- vault auth enable kubernetes


7. Createing Serive account for application pod:

kubectl create ns webapp

kubectl create serviceaccount vault-auth -n webapp

Here when the serivce account is created it will have it's own JWT token which will be signed by Kubernetes when a 
request is sent to vault, vault uses this token for authentication and sends back vault's token by which pods will access the secrets.


8. Configuring Kubernetes Auth in vault:

a. Here we sepecific the value:

SERVICE_ACCOUNT_NAME=vault-auth
NAMESPACE=webapp  # The correct namaspace 

# Get JWT Token
TOKEN_REVIEW_JWT=$(kubectl get secret \
  $(kubectl get serviceaccount $SERVICE_ACCOUNT_NAME -n $NAMESPACE -o jsonpath="{.secrets[0].name}") \
  -n $NAMESPACE -o jsonpath="{.data.token}" | base64 --decode)

# Get Kubernetes API Host
KUBE_HOST=$(kubectl config view --raw -o jsonpath='{.clusters[0].cluster.server}')

# Get Kubernetes CA Certificate
KUBE_CA_CERT=$(kubectl get secret \
  $(kubectl get serviceaccount $SERVICE_ACCOUNT_NAME -n $NAMESPACE -o jsonpath="{.secrets[0].name}") \
  -n $NAMESPACE -o jsonpath="{.data['ca.crt']}" | base64 --decode)

b. Configure in Vault:

kubectl exec -n vault -it vault-0 -- vault write auth/kubernetes/config \
  token_reviewer_jwt="$TOKEN_REVIEW_JWT" \
  kubernetes_host="$KUBE_HOST" \
  kubernetes_ca_cert="$KUBE_CA_CERT"


9. Creating vault policies:

a. Create app_policy.hcl file with:

# Access to read/write secret data for MySQL
path "secret/data/mysql" {
  capabilities = ["create", "update", "read", "delete", "list"]
}

path "secret/data/frontend" {
  capabilities = ["create", "update", "read", "delete", "list"]
}

# Access to list secrets under the path
path "secret/metadata/mysql" {
  capabilities = ["list"]
}

path "secret/metadata/frontend" {
  capabilities = ["list"]
}

# "secret/data/mysql" and "secret/data/frontend" is for storing secrets. 
# "secret/metadata/mysql" and "secret/metadata/frontend" is for storing secrects version history.

b. Apply the file:

kubectl cp app_policy.hcl vault/vault-0:/tmp/app_policy.hcl
kubectl exec -n vault -it vault-0 -- vault policy write app_policy /tmp/app_policy.hcl


10. Creating a role in vault to Map policies to Pods:

kubectl exec -n vault -it vault-0 -- vault write auth/kubernetes/role/vault-role \
  bound_service_account_names=vault-auth \
  bound_service_account_namespaces=webapp \
  policies=app-policy \
  ttl=24h \
  audience="https://kubernetes.default.svc" \
  issuer="https://oidc.eks.eu-north-1.amazonaws.com/id/394F53EB45F4A5C9F405BD609807BB34"

Check the audience inside the pod for debugging purpose if any error occur with audience:

kubectl exec -n <namespace> <pod> -c vault-agent-init -- cat /var/run/secrets/kubernetes.io/serviceaccount/token | cut -d '.' -f2 | base64 -d | jq .



11. Enable KV2 to allow secret versioning:

kubectl exec -n vault -it vault-0 -- vault secrets enable -path=secret -version=2 kv


12. To store/push secrets to vault:

kubectl exec -n vault -it vault-0 -- vault kv put secret/mysql \
  MYSQL_DATABASE=bankappdb \
  MYSQL_ROOT_PASSWORD=Test@123

kubectl exec -n vault -it vault-0 -- vault kv put secret/frontend \
  MYSQL_ROOT_PASSWORD=Test@123

Either we can use this command from cli or use Vault UI to create secrets.


13. Deploy:

Next use specific annotation to make the deployment file to access secrets from vaults like these:

a. 
"
annotations:
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "vault-role"

        # Inject MYSQL_ROOT_PASSWORD
        vault.hashicorp.com/agent-inject-secret-mysql-root-password: "secret/mysql"
        vault.hashicorp.com/agent-inject-template-mysql-root-password: |
          {{- with secret "secret/mysql" -}}
          export MYSQL_ROOT_PASSWORD="{{.Data.data.MYSQL_ROOT_PASSWORD}}"
          {{- end}}

        # Inject MYSQL_DATABASE
        vault.hashicorp.com/agent-inject-secret-mysql-database: "secret/mysql"
        vault.hashicorp.com/agent-inject-template-mysql-database: |
          {{- with secret "secret/mysql" -}}
          export MYSQL_DATABASE="{{.Data.data.MYSQL_DATABASE}}"
          {{- end}}
"

b.
"
annotations:
        vault.hashicorp.com/agent-inject: "true"
        vault.hashicorp.com/role: "vault-role"

        # Inject all MySQL env vars in one template
        vault.hashicorp.com/agent-inject-secret-mysql: "secret/mysql"
        vault.hashicorp.com/agent-inject-template-mysql: |
          {{- with secret "secret/mysql" -}}
          export MYSQL_ROOT_PASSWORD="{{.Data.data.MYSQL_ROOT_PASSWORD}}"
          export MYSQL_DATABASE="{{.Data.data.MYSQL_DATABASE}}"
          {{- end}}
"

The full deployment manifest file in root location for the repo.

